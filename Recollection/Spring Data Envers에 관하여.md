> Spring Data Envers 사용을 경험하며 관련 내용을 정리하여 한다.

### 1. 한 문장 정의
Spring Data Envers는 "DB에 저장된 엔티티의 변경 이력(누가/언제/무엇을 어떻게 바꿨는지)"을 자동으로 별도 감사(Audit) 테이블에 남기고, 그 이력을 Spring Data Repository 스타일로 쉽게 조회할 수 있게 해주는 기능 묶음이다.
핵심은 "감사 데이터 기록은 Hibernate Envers가 담당"하고, "편한 조회 API는 Spring Data Envers가 담당"한다는 구조이다.

### 2. Spring Data Envers와 Hibernate Envers의 역할 분리
#### 2.1. Hibernate Envers가 하는 일(기록 엔진)
- 엔티티에 `@Audited`를 붙이면, 엔티티 변경 시점에 감사 테이블(기본: `<테이블명>_AUD`)로 스냅샷/변경 정보를 저장한다.
- 변경 이벤트마다 Revision(리비전)이라는 "변경 묶음 ID"를 만들고, 감사 테이블에는 이 리비전 번호와 변경 타입(추가/수정/삭제 등)이 같이 저장된다.
#### 2.2. Spring Data Envers가 하는 일(조회 UX)
- Envers가 쌓아둔 이력을 Spring Data Repository 방식으로 조회할 수 있도록 `RevisionRepository` 계열 API를 제공한다.
- 즉, "감사 데이터 저장"이 아니라 "감사 데이터 조회 편의성"이 Spring Data Envers의 존재 이유이다.

### 3. 내부 동작 방식
#### 3.1. 쓰기(변경) 시점에 무슨 일이 일어나는가?
1. 애플리케이션이 트랜잭션 안에서 엔티티를 저장/수정/삭제한다.
2. Hibernate가 flush 시점(보통 트랜잭션 커밋 직전)에 변경 사항을 DB에 반영한다.
3. Envers가 Hibernate 이벤트를 훅킹하여 "이 변경을 감사 테이블에 남겨야 한다"고 판단한다.
4. Envers는 리비전 엔티티(기본 RevisionInfo)를 생성하고 리비전 번호를 만든다.
5. Envers가 `<엔티티_AUD>` 감사 테이블에 "해당 리비전 번호 + 변경 당시 값 + 변경 타입"을 기록한다.
결론적으로, Envers 감사 데이터는 'JPA 변경 감지 + flush' 흐름을 타므로, flush가 건너뛰어지거나 JPA를 우회하면 감사가 누락될 수 있다.

#### 3.2. 조회(이력 읽기) 시점에 무슨 일이 일어나는가?
1. Spriing Data Envers의 `RevisionRepository`가 호출된다.
2. 내부적으로 Envers의 `AuditReader`/감사 쿼리 매커니즘을 이용해 감사 테이블과 리비전 정보를 조합해서 결과를 구성한다.
3. 결과는 "특정 엔티티의 특정 시점 스냅샷" 또는 "리비전 목록(변경 히스토리)" 형태로 반환된다.

### 4. 감사 테이블 데이터 모델(AUD 테이블에 "무엇이" "어떻게" 저장되는가)
#### 4.1. 기본 구조: 원본 테이블의 "스냅샷 + 리비전 메타데이터"
Envers에서 `@Audited`가 붙은 엔티티는 보통 다음 형태의 감사 테이블이 만들어진다.
- 원본 테이블: `member`
- 감사 테이블: `member_AUD`(기본 네이밍 관례)
감사 테이블의 핵심 특징은 "해당 리비전 시점의 엔티티 상태(스냅샷)가 row 단위로 저장된다"는 점이다.
즉, "바뀐 필드만" 저장하는 방식이 아니라, 기본적으로 "그 시점의 엔티티 상태를 복제"하는 방식에 가깝다.

#### 4.2. 감사 테이블의 대표 컬럼 3종 세트: `REV`, `REVTYPE`, (엔티티 컬럼들)
감사 테이블에는 일반적으로 다음이 포함된다.
1. 엔티티의 식별자 컬럼
	- 예: `id`
2. 엔티티의 일반 속성 컬럼들
	- 예: `name`, `email`, `status`, `created_at`, `updated_at` 등(원본 테이블과 유사)
3. Envers 메타 컬럼
	- `REV`: 이 변경이 속한 리비전 번호
	- `REVTYPE`: 변경 타입(추가/수정/삭제)

##### REVTYPE 값의 의미
보통 다음 의미로 사용된다.
- `0`: INSERT(추가)
- `1`: UPDATE(수정)
- `2`: DELETE(삭제)
운영에서 가장 많이 헷갈리는 포인트는 "DELETE도 감사 테이블에는 남는다"는 점이다.
원본 row는 삭제되어도, 감사 테이블에는 "삭제 리비전"의 스냅샷이 남을 수 있다.

#### 4.3. PK(기본키)는 보통 "(엔티티 ID + REV)" 조합이 된다.
감사 테이블은 일반적으로 "동일 엔티티가 여러 번 변경되기 때문에" 단일 `id`로는 PK가 될 수 없다.
그래서 흔히 다음과 같은 형태를 사용한다.
- PK: `(id, REV)`
이 구조 덕분에,
- 특정 엔티티의 모든 변경 이력을 시간 순으로 조회하는 것이 쉽다.
- 조회 성능을 위해 `(id, REV)` 또는 `(id, REV desc)` 계열 인덱스가 매우 중요해진다.

#### 4.4. 리비전 테이블(REVINFO)은 "변경 묶음의 헤더"이다.
`REV`는 혼자 존재하지 않고, 리비전 정보를 담는 "리비전 테이블"과 연결되는 키가 된다.
리비전 테이블에는 보통 다음이 들어간다.
- `REV`: 리비전 번호(증가하는 정수)
- `REVTSTMP`: 리비전 생성 시간(보통 epoch millis)
감사 테이블은 "디테일(상세 스냅샷)"이고, 리비전 테이블은 "헤더(시간/누가/요청정보)"이다.

여기서 "누가 변경했는지(userId)" 같은 메타데이터를 남기고 싶다면, 리비전 테이블을 커스터마이징해서 컬럼을 확장하는 방식이 일반적이다.

#### 4.5. UPDATE 시 감사 테이블에는 "무엇이 들어가는가"
UPDATE가 발생하면 감사 테이블에는 보통 다음이 저장된다.
- 그 시점의 엔티티 스냅샷(대부분의 컬럼 값)
- `REV` (리비전 번호)
- `REVTYPE = 1`
여기서 가장 중요한 함정이 있다.

##### 함정 1: "변경된 필드만 들어간다"라고 오해하면 안된다.
기본적으로는 "스냅샷" 성격이 강하므로, 변경되지 않은 필드도 같이 들어간다.

##### 함정 2: Lazy 연관관계는 "내가 기대한 것처럼" 안 쌓일 수 있다.
연관관계가 복잡할수록, 감사 테이블이
- 연관 FK만 남기는 형태가 되거나,
- 컬렉션은 별도 감사 테이블로 분리되거나,
- 감사 전략에 따라 저장 구조가 달라진다.
따라서 "엔티티 하나에 컬렉션/ManyToMany가 많다"면, 감사 테이블 설계를 미리 검증해야 한다.

#### 4.6. DELETE 시 감사 데이터는 어떻게 남는가
DELETE가 되면 보통 다음이 된다.
- `_AUD` 테이블에 `REVTYPE = 2`인 row가 들어간다.
- 이 row에 "삭제 시점의 값"이 들어갈 수도 있고(스냅샷), 전략/설정에 따라 일부가 달라질 수 있다.
운영 관점에서 중요하게 봐야 하는 질문이 있다.
- "삭제된 데이터의 과거 상태를 조회해야 하는가"
- "삭제 자체가 규정상 민감한 행위이므로, 삭제 행위의 주체/사유까지 남겨야 하는가"
이 요구가 있으면, 리비전 테이블에 메타데이터를 확장하거나, 삭제 이벤트를 별도 감사 로그로 보강하는 설계를 같이 고려하는 편이 안전하다.

### 5. 사용시 유의사항
#### 5.1. JPA를 우회하는 변경은 감사가 누락될 수 있다.
- `@Modifying` JPQL bulk update/delete, native query, DB 트리거 직접 수정, 배치 SQL 등은 영속성 컨텍스트 변경 감지와 flush 호출을 타지 않기 때문에 Envers가 "변경 이벤트"를 놓칠 수 있다.
- 운영에서 "감사 로그가 중간중간 비는" 현상은 대부분 여기서 발생한다. 원칙은 "감사 대상 데이터는 엔티티 변경(Dirty Checking) 경로로 수정한다"이다.

#### 5.2. 감사 테이블은 기본적으로 엔티티 테이블의 "사본"에 가깝다.
- 기본 설정에서 감사 테이블은 `<원본 컬럼들> + REV(리비전) + REVTYPE(변경 타입)` 같은 형태가 된다.
- 즉, 컬럼이 많은 엔티티일수록 저장량이 급격히 늘어난다. 감사 대상 엔티티를 "정말 필요한 것만" 선정해야 한다.

#### 5.3. 감사 데이터는 "로그"가 아니라 "규모가 커지는 운영 데이터"이다.
- 인덱스 설계가 없으면 조회가 금방 느려진다.
- 최소로 고려할 인덱스 후보는 보통 아래와 같다.
	- `<엔티티_AUD>(id, REV)`
	- `<REVINFO>(REV)` 또는 `(timestamp`
- 저장량이 큰 도메인은 파티셔닝/보관 정책(예: 2년 보관 후 아카이브)을 초기에 합의해야 한다.

#### 5.4. "누가 변경했는지"는 기본 제공이 아니다.
- Envers 기본 RevisionInfo는 보통 "리비전 번호/시간" 중심이다.
- "사용자 ID, 요청 IP, 클라이언트, 사유" 같은 것을 남기려면 커스텀 리비전 엔티티 + RevisionListener 설계가 필요하다(감사에게 가장 가치 있는 정보가 대게 이 메타데이터이다).

#### 5.5. 변경 단위는 "엔티티 단위 스냅샷"이다.
- "어떤 필드가 바뀌었는지"를 완벽한 diff 형태로 주는 게 아니라, 기본적으로 해당 리비전의 엔티티 상태를 저장한다.
- 필드 단위 변경 내역이 반드시 필요하면, 추가 설계(애플리케이션 레벨 이벤트/감사 로그 테이블 병행)가 필요할 수 있다.

#### 5.6. 연관관계(컬렉션/ManyToMany)는 성능과 모델링 난이도가 급상승한다.
- 컬렉션 감사는 별도 감사 테이블이 생성되거나 조인 구조가 복잡해질 수 있다.
- "주요 엔티티만 감사하고, 연관 컬렉션은 비감사 처리"가 실무에서 흔한 선택이다.

#### 5.7. 삭제(DELETE)는 특히 주의해야 한다.
- 삭제 시점에 감사 테이블에는 "삭제 리비전"이 남지만, 원본 row는 삭제된다.
- "삭제된 엔티티를 과거 시점으로 복원" 같은 요구가 있으면, 삭제 정책(soft delete)와 감사 정책을 같이 맞춰야 한다.

#### 5.8. 트랜잭션 경계가 곧 리비전 경계가 되는 경우가 많다.
- 동일 트랜잭션에서 여러 엔티티가 바뀌면 보통 같은 리비전으로 묶일 수 있다.
- "요청 1건 = 리비전 1개"를 기대한다면, 트랜잭션 설계와 서비스 계층 경계를 정리해야 한다.

#### 5.9. 스키마 마이그레이션 시 감사 테이블도 같이 진화해야 한다.
- 원본 테이블 컬럼을 바꾸면 감사 테이블도 같이 바뀌어야 한다.
- Flyway/Liquibase 마이그레이션 스크립트에 감사 테이블 변경을 누락하면 운영 배포에서 바로 장애가 난다.

#### 5.10. 감사 대상/비대상 정책을 코드 레벨에서 명확히 고정해야 한다.
- `@Audited`를 "일단 붙이고 보자"로 가면, 6개월 뒤 저장량/성능/컴플라이언스가 터진다.
- 감사 목적을 분류해서 정책화하는 것이 안전하다.
	- 컴플라이언스(필수)
	- 운영 추척(권장)
	- 디버깅(선택, 짧은 보관)

#### 5.11. 개인정보/민감정보는 '그대로 복제'될 위험이 크다.
- 감사 테이블은 원본 값이 그대로 들어간다.
- 따라서 개인정보 마스킹/암호화 정책이 있다면 감사 테이블에도 동일하게 적용해야 한다.
- "원본은 삭제했는데 감사 테이블에 남아있는" 상황이 규정 위반이 될 수 있다.

#### 5.12. Srping Data Envers는 Envers "구성이 이미 정상"이라는 전체를 깔고 있다.
- Spring Data Envers 문서 자체가 "Envers가 올바르게 구성되어 있어야 한다"는 전제를 명시한다.
- 즉, "Spring Data Envers만 붙였는데 자동으로 감사가 켜질 것"이라고 기대하면 안된다.

#### 5.13. 조회 API의 목적은 "편의성"이지 "무제한 자유 쿼리"가 아니다.
- 복잡한 조건 검색, 감사 데이터 분석, 리포팅은 전용 쿼리(AuditQuery)나 별도 집계 테이블이 더 적합할 수 있다.

#### 5.14. 테스트 전략을 바꾸어야 한다.
- 단순 Repository 테스트만으로는 감사 누락을 잡기 어렵다.
- 반드시 포함해야 하는 테스트 케이스가 있다.
	- 엔티티 저장/수정/삭제 시 감사 row가 생기는지 테스트한다.
	- bulk update 경로에서 감사가 남지 않는(또는 남는) 정책을 의도대로 통제했는지 테스트한다.

#### 5.15. 운영 모니터링 포인트가 존재한다.
- 감사 테이블 row 증가율, 디스크 사용량, 주요 조회 쿼리 지연, 리비전 테이블 인덱스 효율을 지표로 잡아야 한다.
- "감사 도입은 기능 추가가 아니라 운영 데이터 시스템 추가"라고 보는 관점이 안전하다.

### 6. 도입시 체크사항
#### 6.1. 정책 체크
- 어떤 엔티티를 감사할지 목록이 확정되어 있다.
- 보관 기간(예: 2년)과 아카이브/삭제 정책이 확정되어 있다.
- 개인정보/민감정보가 감사 테이블에 들어가는지 점검했고, 보호 전략이 확정되어 있다.

#### 6.2. 기술 체크
- bulk update/delete를 사용하는 도메인이 있고, 그 경로에서 감사 누락이 허용되는지 합의되어 있다.
- 스키마 마이그레이션 도구(Flyway/Liquibase)에 감사 테이블 변경이 포함된다.
- 인덱스 설계와 조회 성능 요구사항이 합의되어 있다.

#### 6.3. 메타데이터 체크
- "누가 변경했는지"가 필요하면 커스텀 리비전 엔티티와 리스터 설계가 포함되어 있다.

### 7. 권장 아키텍처 패턴
1. 감사 대상은 "핵심 마스터/계약/정산/권한"처럼 감사 가치가 큰 엔티티로 제한한다.
2. 사용자 식별이 필요하면 커스텀 Revision Entity로 `userId`, `ip`, `requestId`를 저장한다.
3. bulk update가 필요한 구간은 "감사 제외"로 명확히 하거나, 별도 감사 로그 테이블(애플리케이션 이벤트 기반)을 병행한다.
4. 감사 조회는 `RevisionRepository`로 80%를 해결하고, 복잡 분석은 별도 리포팅 파이프라인을 둔다.