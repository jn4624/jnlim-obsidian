### 1. 핵심 원인(1) - 스쿼시는 "새 커밋"을 만든다.
feature 브랜치에 커밋이 이렇게 있었다고 하겠다.
- feature: `A - B - C` (여러 커밋)
이를 master(main)에 Squash merge 하면 master에는 이렇게 들어간다.
- master: `S` (A, B, C의 변경사항을 한 번에 담은 "새 커밋")
여기서 중요한 점이 있다.
- master에는 A/B/C 커밋 자체는 존재하지 않는다.
- master에는 S라는 전혀 다른 커밋 해시만 존재한다.
- Git 입장에서는 "A/B/C가 머지되었다"는 증거(머지 커밋)도 없다.
즉, 내용은 들어갔지만 커밋 단위로는 연결고리가 끊긴 상태가 된다.
---

### 2. 핵심 원인(2) - 다음 작업 브랜치를 "어디서 따느냐"가 중복을 만든다.
중복이 주로 터지는 패턴은 이렇다.
- (좋음) 새 기능을 최신 master에서 브랜치를 브랜치를 딴다.
- (문제) 새 기능을 예전 feature 브랜치에서 따거나, 스쿼시 머지되기 전 시점의 master를 기반으로 딴 브랜치를 계속 들고 간다.
예를 들어,
1. feature1을 만들어 `A-B-C` 커밋을 쌓음
2. feature1을 master에 squash merge 해서 master에 `S`가 생김
3. 그런데 feature2를 feature1에서 따거나, feature1을 계속 재사용함
4. feature2에는 히스토리상 `A-B-C`가 그대로 포함됨
5. feature2를 master에 "일반 머지"하려고 하면 Git은 `A-B-C`를 새 커밋으로 보고 다시 포함시킴
이때 실제 파일 변경은 이미 master에 반영되어 있어서,
- PR 화면에서는 커밋이 중복으로 보이거나
- 머지 시 충돌/불필요한 diff가 생기거나
- 어떤 방식으로는 이미 반영된 변경을 또 적용하려고 시도한다.
정리하면, 스쿼시 머지 + (예전 기반 브랜치/브랜치 재사용/스택 브랜치) 조합이 중복을 만든다.
---

### 3. 중복이 안 생기게 하려면 어떻게 해야 하나?
#### 3.1. 가장 권장되는 규칙 - "항상 최신 master에서 새 브랜치를 딴다."
- feature 브랜치는 머지(특히 squash)되면 바로 삭제하는 습관이 가장 안전하다.
- 다음 작업은 반드시 master의 HEAD에서 새로 브랜치를 만든다.
이 한 줄이 사실상 정답에 가깝다.

#### 3.2. 이미 "feature 위에 feature(스택)"로 개발했다면? - rebase로 기반을 갈아탄다.
feature2를 feature1에서 딴 상태에서 feature1이 squash로 들어갔다면, feature2는 그대로 머지하면 중복이 날 확률이 크다. 이때는 feature2를 최신 master 위로 rebase 해야 한다.

대표 패턴은 다음과 같다.
- 최신 master로 이동 후
- feature2를 rebase(또는 `--onto`로 기반을 교체)
개념적으로는 "feature1에서 가져온 커밋들을 feature2 히스토리에서 떼어내고, master 위에 다시 얹는다" 이다.

#### 3.3. "스쿼시 머지" 자체를 줄이는 선택지도 있다.
만약 팀에서 "스택 브랜치"가 잦거나, 히스토리 연결이 중요하다면,
- Merge commit 방식(일반 merge, no-ff)을 쓰면 Git이 "이 브랜치는 이미 머지됨"을 정확히 기억한다.
- 반대로 스쿼시는 히스토리를 깔끔하게 하지만, 그 만큼 브랜치 간 관계 추적이 약해진다.
즉,
- "깔끔한 히스토리"가 최우선이면 스쿼시 + 엄격한 브랜치 삭제/재생성 규칙이 필요하고,
- "브랜치 관계/추적"이 최우선이면 merge commit이 편하다.

### 4. release 브랜치를 중간에 두면 해결되지 않나?
결론부터 말하면, release 브랜치를 둔다고 이 문제가 근본적으로 해결되지는 않는다.

이 문제가 발생하는 이유는
- "어디에 스쿼시했는가(master냐 release냐)"가 아니라
- 스쿼시가 커밋 연속성을 끊고
- 그 이전 기반의 브랜치를 계속 머지하려고 하기 때문이다.
release 브랜치는 보통,
- 배포 안정화,
- QA,
- hotfix 관리
같은 목적에 더 적합하다.

중복 문제를 막는 핵심은 여전히 다음 두 가지이다.
1. 새 브랜치는 항상 최신 master에서 만든다.
2. 스택 브랜치가 필요하면 rebase로 기반을 최신 master로 옮긴다.
---

### 5. 결론
결론적으로, 스쿼시 머지는 feature 브랜치의 여러 커밋을 그대로 master에 연결해 주는 방식이 아니라 변경사항을 하나의 "새 커밋"으로 재작성하는 방식이라서, Git이 "이 브랜치의 커밋들이 이미 병합되었다"는 관계를 커밋 단위로 추적하기 어렵다.
그래서 스쿼시 머지 이후에도 이전 feature 브랜치(또는 그 브랜치를 기반으로 한 브랜치)를 재사용하거나, 스쿼시 머지 이전 시점의 베이스를 가진 브랜치를 그대로 master에 병합하려고 하면, 과거 커밋들이 다시 병합 대상에 포함되어 중복 내역처럼 보이거나 불 필요한 충돌이 발생할 수 있다.

이 문제를 예방하는 가장 확실한 방법은 스쿼시 머지 후 해당 feature 브랜치를 정리하고, 다음 작업 브랜치는 항상 최신 master 기준으로 새로 생성하는 개발 규칙을 지키는 것이다.
만약 feature 위에 feature를 쌓는 방식이 불가피하다면, master로 rebase하여 베이스를 갱신한 뒤 병합해야 한다.

반면 release 브랜치를 중간에 두는 방식은 스쿼시의 본질적 특성을 바꾸지 못하므로 중복 문제의 근본 해결책이 되지 않으며, release 브랜치는 배포 안정화와 QA 같은 목적에 맞게 별도로 운용하는 것이 적절하다.